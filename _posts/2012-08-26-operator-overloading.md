---
layout: doc
title: 函数重载 | Operator overloading
original-doc: http://confluence.jetbrains.net/display/Kotlin/Operator+overloading
---

## 惯例

这里我们描述控制各种符号的重载的惯例。

### 一元符号

| 表达式 | 翻译成    |
| --     |  --       |
| +a     | a.plus    |
| -a     | a.minus() |
| !a     | a.not()   |

这个表内容说明当编译器处理一个表达式(如`+a`)时，经过如下几步：

1. 确定a的类型，设为T
1. 寻找一个函数plus()，没有参数，接受类型为T
1. 如果函数找不到或者有歧义，则抱编译错误
1. 如果函数存在，并且返回类型为R，则`+a`的返回类型为R

**注意**这些符号，以及其他的符号，对[基本类型](posts/basic-types)都进行了性能优化，所以对它们的函数调用并不带来性能损耗。

| 表达式 | 翻译成             |
|  --    |  --                |
|  a++   | a.inc() + 参看下方 |
|  a--   | a.dec() + 参看下方 |

这些操作符会修改他们的接受者，并且(可能)返回一个值

<div class="warn">
inc()/dec()不应该修改接受对象
我们说“修改他们的接受者”，是指接受变量，而不是接受对象
</div>

编译器依据如下步骤来解析一个**后缀**操作符(如`a++`)：

1. 确定a的类型，设为T
1. 寻找一个函数inc()，没有参数，接受类型为T
1. 如果函数返回的类型为R，那么它必须是T的子类

这个表达式计算的效果是：

1. 存放初始的值到一个临时存储a0上
1. 将a.inc()的结果赋值给a
1. 将a0的值作为表达式的结果返回

对于`a--`，上述步骤是类似的。


